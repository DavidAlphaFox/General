#!/usr/bin/env python3

import json
import sys

# @todo Develop an autodoc-like extension to skip the .json file and slim the .rst file
# @todo Develop an doctests-like extension

class Generator:
    def __init__(self, reference):
        self.__reference = reference
        self.__reference.pop("hidden")

    def __call__(self):
        yield "========="
        yield "Reference"
        yield "========="
        yield ""
        yield ".. WARNING This file is generated by autoocamldoc. Manual changes will be lost."
        yield ""
        yield from self.__dispatch(self.__reference)

    def __dispatch(self, element):
        c = element.pop("__class__")
        a = "_Generator__gen__{}".format("__".join(c.split(":")))
        if hasattr(self, a):
            yield from getattr(self, a)(element)
        else:  # pragma no cover
            yield from self.__not_yet_documented(c, element)
        assert element == {}, (c, element)  # Asserts everything was used

    def __not_yet_documented(self, c, x):  # pragma no cover
        assert isinstance(x, dict)
        yield "Not yet documented: {}".format(c)
        for k in list(x.keys()):
            del x[k]
        yield ""

    def __gen__signature_item__module(self, module):
        yield ".. module:: {}".format(module.pop("name"))
        yield ""
        for doc in module.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""
        yield from self.__indent(self.__dispatch(module.pop("type")))

    def __gen__signature_item__module_type(self, module_type):
        yield ".. module_type:: {}".format(module_type.pop("name"))
        yield ""
        for doc in module_type.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""
        yield from self.__indent(self.__dispatch(module_type.pop("type")))

    def __gen__signature_item__include(self, include):
        yield ".. include::"
        yield ""
        for doc in include.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""
        yield from self.__indent(self.__dispatch(include.pop("type")))

    def __gen__signature_item__floating_documentation(self, floating_documentation):
        yield from self.__gen_doc(floating_documentation.pop("text"))
        yield ""

    def __gen__signature_item__value(self, value):
        yield ".. val:: {}".format(value.pop("name"))
        yield "  :type: {}".format(value.pop("type"))
        yield ""
        for doc in value.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__signature_item__type(self, type_):
        yield ".. type:: {}".format(type_.pop("name"))
        parameters = type_.pop("parameters")
        if len(parameters) == 1:
            yield "  :parameters: {}".format(parameters[0])
        elif len(parameters) > 1:
            yield "  :parameters: ({})".format(", ".join(parameters))
        manifest = type_.pop("manifest")
        if manifest:
            yield "  :manifest: {}".format(manifest)
        kind = type_.pop("kind")
        c = kind["__class__"]
        if c == "type_kind:variant":
            for constructor in kind["constructors"]:
                arguments = constructor["arguments"]
                c = arguments["__class__"]
                if c == "arguments:tuple":
                    payload = " * ".join(
                        "({})".format(x) if "*" in x else x
                        for x in arguments["payload"]
                    )
                else:
                    assert c == "arguments:record"
                    payload = "{{{}}}".format("; ".join("{}: {}".format(label["name"], label["type"]) for label in arguments["labels"]))
                if payload:
                    payload = " of {}".format(payload)
                yield ""
                yield "  :constructor {}{}: {}".format(constructor["name"], payload, " ".join(x.strip() for x in constructor["doc"]))
                if c == "arguments:record":
                    for label in arguments["labels"]:
                        yield ""
                        yield "  :label {}: {}".format(label["name"], " ".join(x.strip() for x in label["doc"]))
        elif c == "type_kind:record":
            yield "  :kind: {{{}}}".format("; ".join("{}: {}".format(label["name"], label["type"]) for label in kind["labels"]))
            for label in kind["labels"]:
                yield ""
                yield "  :label {}: {}".format(label["name"], " ".join(x.strip() for x in label["doc"]))
        else:
            assert c == "type_kind:abstract"
        yield ""
        for doc in type_.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__signature_item__exception(self, exception_):
        yield ".. exception:: {}".format(exception_.pop("name"))
        arguments = exception_.pop("arguments")
        c = arguments["__class__"]
        if c == "arguments:tuple":
            payload = " * ".join(
                "({})".format(x) if "*" in x else x
                for x in arguments["payload"]
            )
            if payload:
                yield "  :payload: {}".format(payload)
        else:
            assert c == "arguments:record"
            yield "  :payload: {{{}}}".format("; ".join("{}: {}".format(label["name"], label["type"]) for label in arguments["labels"]))
            for label in arguments["labels"]:
                yield ""
                yield "  :label {}: {}".format(label["name"], " ".join(x.strip() for x in label["doc"]))
        yield ""
        for doc in exception_.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__module_type__signature(self, signature):
        # for doc in signature.pop("doc", []):
        #     yield from self.__gen_doc(doc)
        #     yield ""
        for element in signature.pop("elements"):
            if not element.pop("hidden"):
                yield from self.__dispatch(element)

    # def __gen__module_type__identifier(self, identifier):
    #     yield "Type: {}".format(identifier.pop("name"))  # @todo Display name properly
    #     yield ""
    #     yield from self.__dispatch(identifier.pop("resolved_type"))

    def __gen_doc(self, text):
        lines = text.strip().splitlines()
        yield lines[0]
        if len(lines) > 1:
            lines = lines[1:]
            leading_spaces = min(self.__count_leading_spaces(line) for line in lines if line)
            for line in lines:
                if line:
                    assert line.startswith(" " * leading_spaces), (line, leading_spaces)
                    yield line[leading_spaces:]
                else:
                    yield ""

    def __count_leading_spaces(self, s):
        for i in range(len(s)):  # pragma no branch
            if s[i] != " ":
                return i
        return 0  # pragma no cover

    def __indent(self, lines):
        for line in lines:
            if line:
                yield "  " + line
            else:
                yield ""

def ensure_single_lines(lines):
    for line in lines:
        yield " ".join(part.rstrip() for part in line.splitlines())

def main(input_file=sys.stdin, output_file=sys.stdout):
    generator = Generator(json.load(input_file))
    for line in ensure_single_lines(generator()):
        output_file.write(line)
        output_file.write("\n")

if __name__ == "__main__":  # pragma no cover
    main()
