#!/usr/bin/env python3

import json
import sys

# @todo Develop an autodoc-like extension to skip the .json file and slim the .rst file
# @todo Develop an doctests-like extension

class Generator:
    def __init__(self, reference):
        self.__reference = reference
        self.__reference.pop("hidden")

    def __call__(self):
        yield "========="
        yield "Reference"
        yield "========="
        yield ""
        yield ".. WARNING This file is generated by autoocamldoc. Manual changes will be lost."
        yield ""
        yield from self.__gen__signature_item__module(self.__reference)

    def __gen__signature_item__module(self, module):
        yield ".. module:: {}".format(module.pop("name"))
        yield ""
        yield from self.__indent(self.__doc(module))
        yield from self.__indent(self.__module_contents(module))

    def __indent(self, lines):
        for line in lines:
            if line:
                yield "  " + line
            else:
                yield ""

    def __doc(self, thing):
        for doc in thing.pop("doc"):
            yield from self.__gen_doc(doc)
            yield ""

    def __gen_doc(self, text):
        lines = text.strip().splitlines()
        yield lines[0]
        if len(lines) > 1:
            lines = lines[1:]
            leading_spaces = min(self.__count_leading_spaces(line) for line in lines if line)
            for line in lines:
                if line:
                    assert line.startswith(" " * leading_spaces), (line, leading_spaces)
                    yield line[leading_spaces:]
                else:
                    yield ""

    def __count_leading_spaces(self, s):
        for i in range(len(s)):  # pragma no branch
            if s[i] != " ":
                return i
        return 0  # pragma no cover

    def __module_contents(self, thing):
        for parameter in thing.pop("functor_parameters"):
            yield ".. functor_parameter:: {}".format(parameter.pop("name"))
            yield ""
            yield from self.__indent(self.__module_contents(parameter))
        yield from self.__contents(thing)

    def __contents(self, thing):
        for content in thing.pop("contents"):
            if not content.pop("hidden"):
                c = content.pop("__class__")
                a = "_Generator__gen__{}".format("__".join(c.split(":")))
                yield from getattr(self, a)(content)
                assert content == {}, (c, content)  # Asserts everything was used

    def __gen__signature_item__module_type(self, module_type):
        yield ".. module_type:: {}".format(module_type.pop("name"))
        yield ""
        yield from self.__indent(self.__doc(module_type))
        yield from self.__indent(self.__contents(module_type))

    def __gen__signature_item__include(self, include):
        yield ".. include::"
        yield ""
        yield from self.__indent(self.__doc(include))
        yield from self.__indent(self.__contents(include))

    def __gen__signature_item__floating_documentation(self, floating_documentation):
        yield from self.__gen_doc(floating_documentation.pop("text"))
        yield ""

    def __gen__signature_item__value(self, value):
        yield ".. val:: {}".format(value.pop("name"))
        yield "  :type: {}".format(value.pop("type"))
        yield ""
        for doc in value.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__signature_item__type(self, type_):
        yield ".. type:: {}".format(type_.pop("name"))
        parameters = type_.pop("parameters")
        if len(parameters) == 1:
            yield "  :parameters: {}".format(parameters[0])
        elif len(parameters) > 1:
            yield "  :parameters: ({})".format(", ".join(parameters))
        manifest = type_.pop("manifest")
        if manifest:
            yield "  :manifest: {}".format(manifest)
        kind = type_.pop("kind")
        c = kind["__class__"]
        if c == "type_kind:variant":
            for constructor in kind["constructors"]:
                arguments = constructor["arguments"]
                c = arguments["__class__"]
                if c == "arguments:tuple":
                    payload = " * ".join(
                        "({})".format(x) if "*" in x else x
                        for x in arguments["payload"]
                    )
                else:
                    assert c == "arguments:record"
                    payload = "{{{}}}".format("; ".join("{}: {}".format(label["name"], label["type"]) for label in arguments["labels"]))
                if payload:
                    payload = " of {}".format(payload)
                yield ""
                yield "  :constructor {}{}: {}".format(constructor["name"], payload, " ".join(x.strip() for x in constructor["doc"]))
                if c == "arguments:record":
                    for label in arguments["labels"]:
                        yield ""
                        yield "  :label {}: {}".format(label["name"], " ".join(x.strip() for x in label["doc"]))
        elif c == "type_kind:record":
            yield "  :kind: {{{}}}".format("; ".join("{}: {}".format(label["name"], label["type"]) for label in kind["labels"]))
            for label in kind["labels"]:
                yield ""
                yield "  :label {}: {}".format(label["name"], " ".join(x.strip() for x in label["doc"]))
        else:
            assert c == "type_kind:abstract"
        yield ""
        for doc in type_.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__signature_item__exception(self, exception_):
        yield ".. exception:: {}".format(exception_.pop("name"))
        arguments = exception_.pop("arguments")
        c = arguments["__class__"]
        if c == "arguments:tuple":
            payload = " * ".join(
                "({})".format(x) if "*" in x else x
                for x in arguments["payload"]
            )
            if payload:
                yield "  :payload: {}".format(payload)
        else:
            assert c == "arguments:record"
            yield "  :payload: {{{}}}".format("; ".join("{}: {}".format(label["name"], label["type"]) for label in arguments["labels"]))
            for label in arguments["labels"]:
                yield ""
                yield "  :label {}: {}".format(label["name"], " ".join(x.strip() for x in label["doc"]))
        yield ""
        for doc in exception_.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""


def ensure_single_lines(lines):
    for line in lines:
        yield " ".join(part.rstrip() for part in line.splitlines())

def main(input_file=sys.stdin, output_file=sys.stdout):
    generator = Generator(json.load(input_file))
    for line in ensure_single_lines(generator()):
        output_file.write(line)
        output_file.write("\n")

if __name__ == "__main__":  # pragma no cover
    main()
