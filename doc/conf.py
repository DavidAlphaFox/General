# coding: utf8

# Copyright 2017 Vincent Jacques <vincent@vincent-jacques.net>

import glob
import json
import os
import sys
import textwrap


master_doc = "index"
project = "General"
author = '<a href="http://vincent-jacques.net/">Vincent Jacques</a>'
copyright = ('2017 {} <script>var jacquev6_ribbon_github="{}"</script>'.format(author, project) +
             '<script src="https://jacquev6.github.io/ribbon.js"></script>')
extensions = []

# Local directory sphinx-ocaml
sys.path.append(os.path.join(os.path.dirname(__file__), "sphinx-ocaml"))
extensions.append("ocaml")
primary_domain = "ocaml"

nitpicky = True
nitpick_ignore = [
]

# https://github.com/bitprophet/alabaster
# html_theme_path
extensions.append("alabaster")
html_theme = "alabaster"
html_sidebars = {
    "**": ["about.html", "navigation.html", "searchbox.html"],
}
html_theme_options = {
    "github_user": "jacquev6",
    "github_repo": project,
    "travis_button": True,
}
# html_logo = "logo.png"

# @todoc Develop an autodoc-like extension to skip the .json file and slim the .rst file
# @todoc Develop an doctests-like extension

class Generator:
    def __init__(self, reference):
        self.__reference = reference
        self.__reference.pop("hidden")

    def __call__(self):
        yield "========="
        yield "Reference"
        yield "========="
        yield ""
        yield ".. WARNING This file is generated by conf.py. Manual changes will be lost."
        yield ""
        yield from self.__dispatch(self.__reference)

    def __dispatch(self, element):
        c = element.pop("__class__")
        a = "_Generator__gen__{}".format("__".join(c.split(":")))
        if hasattr(self, a):
            yield from getattr(self, a)(element)
        else:
            yield from self.__not_yet_documented(c, element)
        assert element == {}, (c, element)  # Asserts everything was used

    def __not_yet_documented(self, c, x):
        assert isinstance(x, dict)
        yield "Not yet documented: {}".format(c)
        for k in list(x.keys()):
            del x[k]
        yield ""

    def __gen__signature_item__module(self, module):
        yield ".. module:: {}".format(module.pop("name"))
        yield ""
        for doc in module.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""
        yield from self.__indent(self.__dispatch(module.pop("type")))

    def __gen__signature_item__floating_documentation(self, floating_documentation):
        yield from self.__gen_doc(floating_documentation.pop("text"))
        yield ""

    def __gen__signature_item__value(self, value):
        yield ".. val:: {}".format(value.pop("name"))
        yield "  :type: {}".format(value.pop("type"))
        yield ""
        for doc in value.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__signature_item__type(self, type_):
        yield ".. type:: {}".format(type_.pop("name"))
        parameters = type_.pop("parameters")
        if len(parameters) == 1:
            yield "  :parameters: {}".format(parameters[0])
        elif len(parameters) > 1:
            yield "  :parameters: ({})".format(", ".join(parameters))
        manifest = type_.pop("manifest")
        if manifest:
            yield "  :manifest: {}".format(manifest)
        yield ""
        for doc in type_.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""
        # @todo Use the following attributes
        type_.pop("kind")

    def __gen__signature_item__exception(self, exception_):
        yield ".. exception:: {}".format(exception_.pop("name"))
        payload = exception_.pop("payload")
        if payload:
            yield "  :payload: {}".format(" * ".join(
                "({})".format(x) if "*" in x else x
                for x in payload
            ))
        yield ""
        for doc in exception_.pop("doc"):
            yield from self.__indent(self.__gen_doc(doc))
            yield ""

    def __gen__module_type__signature(self, signature):
        for element in signature.pop("elements"):
            if not element.pop("hidden"):
                yield from self.__dispatch(element)

    def __gen_doc(self, text):
        lines = text.strip().splitlines()
        yield lines[0]
        if len(lines) > 1:
            lines = lines[1:]
            leading_spaces = min(self.__count_leading_spaces(line) for line in lines if line)
            for line in lines:
                if line:
                    assert line.startswith(" " * leading_spaces), (line, leading_spaces)
                    yield line[leading_spaces:]
                else:
                    yield ""

    def __count_leading_spaces(self, s):
        for i in range(len(s)):
            if s[i] != " ":
                return i
        return 0

    def __indent(self, lines):
        for line in lines:
            if line:
                yield "  " + line
            else:
                yield ""

def ensure_single_lines(lines):
    for line in lines:
        yield " ".join(part.rstrip() for part in line.splitlines())


with open("reference.json") as f:
    generator = Generator(json.load(f))

with open("reference.rst", "w") as f:
    for line in ensure_single_lines(generator()):
        f.write(line)
        f.write("\n")
